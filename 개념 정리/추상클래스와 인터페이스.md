## 추상클래스 (abstract class)

- 클래스가 설계도라면 추상클래스는 **미완성 설계도**
- 추상메서드를 포함하고 있는 클래스
- **추상메서드 (abstract method)**
    - 선언부만 있고 구현부(몸통, body)가 없는 메서드
    - `abstract 리턴타입 메서드이름();`
    - **꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용**
    - **추상클래스를 상속 받는 자식클래스에서 추상메서드의 구현부를 완성해야 함**
- 일반메서드가 추상메서드를 호출할 수 있다.
- 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
- 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성된다.
- 여러 클래스에 **공통적으로 사용될 수 있는 추상클래스**를 바로 작성하거나, 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.

## 인터페이스

- **추상메서드의 집합 + 변수를 가질 수 없음! (상수만 가능)**
- 실제 구현된 것이 전혀 없는 **기본 설계도**
- **추상메서드와 상수만을 멤버로 가질 수 있다. (변수 X)**
- 인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
- **미리 정해진 규칙에 맞게 구현하도록 표준을 제시**하는 데 사용된다.
- **인터페이스 작성**
    - ‘class’ 대신 ‘interface’ 를 사용한다는 것 외에는 클래스 작성과 동일하다.
    - 하지만, **구성요소(멤버)는 추상메서드와 상수만 가능**하다.
    
    ```java
    public interface Interface01 {
        
    	// 모든 멤버변수는 public static final 이어야 하며, 생략할 수 있다.
        public static final 타입 상수이름 = 값;
    
    	// 모든 메서드는 public abstract 이어야 하며, 생략할 수 있다.
        public abstract 리턴타입 메서드이름(매개변수);
    
    }
    ```
    

- **인터페이스 상속**
    - 인터페이스도 클래스처럼 상속이 가능하다. (클래스와 달리 **다중상속 허용**)
    - `interface Fightable extends Movable, Attackable {  }`
    - 인터페이스는 Object 클래스와 같은 최고 조상이 없다.
    
- **인터페이스 구현**
    - 구현 : 추상메서드의 몸통을 작성해주는 것
    - 인터페이스를 구현하는 것은 클래스를 상속받는 것과 같다.
    - extends 대신 implements 를 사용한다.
    - **인터페이스에 정의된 추상메서드를 모두 구현해야 한다.**
    - **상속과 구현이 동시에 가능**하다. `class Fighter extends Unit implements Fightable {  }`
    
- **인터페이스 다형성**
    - 인터페이스 타입의 변수로 인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있다. (인터페이스도 구현 클래스의 부모)
    `Fighter f = new Fighter();`  `Fightable f = new Fighter();`
    - 인터페이스를 메서드의 매개변수 타입으로 지정할 수 있다. 
    `void attack(Fightable f) {  }`
    - 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.
    `Fightable method() { .. return new Fightable(); }`
    
- **인터페이스 장점**
    - 개발 시간을 단축 할 수 있다. → 메서드를 호출하는 쪽에서는 선언부만 알면 되기 때문에 인터페이스를 구현하는 클래스를 기다리지 않고 양쪽에서 동시에 개발 진행 가능
    - 표준화가 가능하다. → 프로젝트에 사용되는 기본 틀을 인터페이스로 작성함으로써 일관되고 정형화된 프로그램 개발이 가능
    - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. → 상속관계이거나, 같은 조상클래스를 가지고 있는 관계가 아닌 클래스들이 하나의 인터페이스를 공통적으로 구현함으로써 관계가 맺어짐
    - 독립적인 프로그램이 가능하다. → 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제 구현에 독립적인 프로그램을 작성하는 것이 가능
    
- **디폴트 메서드(default method)**
    - JDK 1.8 부터 디폴트 메서드와 static 메서드 기능 추가됨
    - 인터페이스에 새로운 메서드를 추가하면 기존에 이 인터페이스를 구현한 모든 클래스가 이 메서드를 구현해야 함
    - 이 문제를 해결하기 위해 ‘디폴트 메서드' 가 나옴
    - 디폴트 메서드는 몸통(구현부)를 가지고 있다. 앞에 ‘default’ 를 붙이고 항상 public 이다. (생략 가능)
    `default void newMethod() {  }`

- **추상클래스 vs 인터페이스**
    - 추상클래스 : 일반 클래스 개념에 추상메서드를 가지고 있는 클래스 (멤버변수를 가질 수 있음)
    - 인터페이스 : 아무것도 구현되어 있는게 없는 추상메서드의 집합 (멤버변수 가질 수 없음 / 상수만 가능)
    - 공통점 : 추상 메서드를 가지고 있다.
    - 차이점 : 인터페이스는 멤버변수를 가질 수 없다.

## 내부 클래스(inner class)

- 클래스 안의 클래스
- 내부 클래스에서 객체 생성 없이도 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다. (캡슐화)
- 내부 클래스의 종류와 유효범위는 변수(iv,cv,lv)와 동일
- 내부 클래스의 접근제어자는 변수에 사용할 수 있는 접근제어자와 동일하다.
- static 클래스만 static 멤버를 정의할 수 있다.
- 내부 클래스도 외부 클래스의 멤버로 간주되며, 동일한 접근성을 갖는다.
- 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스 (일회용, 이벤트 처리에 주로 사용됨)
